/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package jdk.incubator.jbind;

import java.lang.invoke.MethodType;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import jdk.incubator.foreign.Foreign;
import jdk.incubator.foreign.FunctionDescriptor;
import jdk.incubator.foreign.GroupLayout;
import jdk.incubator.foreign.MemoryAddress;
import jdk.incubator.foreign.MemoryLayout;
import jdk.incubator.foreign.MemorySegment;
import jdk.incubator.foreign.SequenceLayout;
import jdk.incubator.foreign.SystemABI;
import jdk.incubator.foreign.ValueLayout;
import jdk.incubator.jextract.Declaration;

/**
 * A helper class to generate header interface class in source form.
 * After aggregating various constituents of a .java source, build
 * method is called to get overall generated source string.
 */
class JavaSourceBuilder {
    private static final String ABI = Foreign.getInstance().getSystemABI().name();
    // buffer
    protected StringBuffer sb;
    // current line alignment (number of 4-spaces)
    protected int align;

    JavaSourceBuilder(int align) {
        this.align = align;
        this.sb = new StringBuffer();
    }

    JavaSourceBuilder() {
        this(0);
    }

    protected int align() {
        return align;
    }

    final String PUB_CLS_MODS = "public final ";
    final String PUB_MODS = "public static final ";
    final String PRI_MODS = "private static final ";

    protected void addPackagePrefix(String pkgName) {
        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
        sb.append("// Generated by jbind\n\n");
        if (!pkgName.isEmpty()) {
            sb.append("package ");
            sb.append(pkgName);
            sb.append(";\n\n");
        }
        addImportSection();
    }

    private static String AbiTypes() {
        String prefix = "jdk.incubator.foreign.MemoryLayouts.";
        switch (ABI) {
            case SystemABI.ABI_SYSV:
                return prefix + "SysV";
            case SystemABI.ABI_WINDOWS:
                return prefix + "WinABI";
            case SystemABI.ABI_AARCH64:
                return prefix + "AArch64ABI";
            default:
                throw new UnsupportedOperationException("Unsupported ABI: " + ABI);
        }
    }

    protected void addImportSection() {
        sb.append("import com.oracle.jbind.core.*;\n");
        sb.append("import java.lang.invoke.MethodHandle;\n");
        sb.append("import java.lang.invoke.VarHandle;\n");
        sb.append("import jdk.incubator.foreign.*;\n");
        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
        sb.append("import static ");
        sb.append(AbiTypes());
        sb.append(".*;\n\n");
    }

    protected void addImport(String value) {
        sb.append("import " + value + ";\n");
    }

    protected void classBegin(String name) {
        indent();
        sb.append(PUB_CLS_MODS + "class ");
        sb.append(name);
        sb.append(" {\n");
        incrAlign();
    }

    protected void classBegin(boolean isStatic, String name, String superClass, String... superInterfaces) {
        indent();
        sb.append(isStatic ? PUB_MODS : PUB_CLS_MODS);
        sb.append("class ");
        sb.append(name);
        if (superClass != null && !superClass.isEmpty()) {
            sb.append(" extends " + superClass);
        }
        if (superInterfaces != null && superInterfaces.length != 0) {
            sb.append(" implements ");
            sb.append(String.join(", ", superInterfaces));
        }
        sb.append(" {\n");
        incrAlign();
    }

    protected void classEnd() {
        decrAlign();
        indent();
        sb.append("}\n\n");
    }

    protected void addLibraries(String[] libraryNames, String[] libraryPaths) {
        indent();
        sb.append(PRI_MODS + "LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(");
        sb.append(stringArray(libraryNames) + ", " + stringArray(libraryPaths) + ");\n");
    }

    private String stringArray(String[] elements) {
        return Stream.of(elements)
                .map(n -> "\"" + n + "\"")
                .collect(Collectors.joining(",", "new String[] {", "}"));
    }

    private String getLayoutName(String elementName) {
        return elementName + "$LAYOUT";
    }

    protected void addLayout(String elementName, MemoryLayout layout) {
        indent();
        sb.append(PUB_MODS + "MemoryLayout " + getLayoutName(elementName) + " = ");
        addLayout(layout);
        sb.append(";\n");
    }

    protected void addStructConstructor(String name) {
        String layoutVar = getLayoutName(name);
        indent();
        sb.append("protected " + name + "(MemoryAddress addr) { super(addr); }\n");
        indent();
        sb.append(PUB_MODS + name + " at(MemoryAddress addr) { return new " + name + "(addr); }\n");
        indent();
        sb.append(PUB_MODS + name + " allocate(LongFunction<MemoryAddress> allocator, int count) {\n");
        incrAlign();
        indent();
        sb.append("return new " + name + "(allocator.apply(" + layoutVar + ".byteSize() * count));\n");
        decrAlign();
        indent();
        sb.append("}\n\n");
        indent();
        sb.append(PUB_MODS + name + " allocate(LongFunction<MemoryAddress> allocator) { return allocate(allocator, 1); }\n");
        indent();
        sb.append(PUB_CLS_MODS + name + " offset(int count) { return at(ptr().addOffset("
                + layoutVar + ".byteSize() * count)); }\n\n");
    }

    protected void addLayoutMethod(String elementName, GroupLayout layout) {
        indent();
        String varName = getLayoutName(elementName);
        sb.append(PUB_MODS + "GroupLayout " + varName + " = ");
        addLayout(layout);
        sb.append(";\n");
        indent();
        sb.append("@Override\n");
        indent();
        sb.append(PUB_CLS_MODS + "GroupLayout getLayout() {\n");
        incrAlign();
        indent();
        sb.append("return ");
        sb.append(varName);
        sb.append(";\n");
        decrAlign();
        indent();
        sb.append("}\n\n");
    }

    private void addLayout(MemoryLayout l) {
        if (l instanceof ValueLayout) {
            SystemABI.Type type = l.abiType().orElseThrow(()->new AssertionError("Should not get here: " + l));
            sb.append(switch (type) {
                case BOOL -> "C_BOOL";
                case SIGNED_CHAR -> "C_SCHAR";
                case UNSIGNED_CHAR -> "C_UCHAR";
                case CHAR -> "C_CHAR";
                case SHORT -> "C_SHORT";
                case UNSIGNED_SHORT -> "C_USHORT";
                case INT -> "C_INT";
                case UNSIGNED_INT -> "C_UINT";
                case LONG -> "C_LONG";
                case UNSIGNED_LONG -> "C_ULONG";
                case LONG_LONG -> "C_LONGLONG";
                case UNSIGNED_LONG_LONG -> "C_ULONGLONG";
                case FLOAT -> "C_FLOAT";
                case DOUBLE -> "C_DOUBLE";
                case LONG_DOUBLE -> "C_LONGDOUBLE";
                case POINTER -> "C_POINTER";
                default -> { throw new RuntimeException("should not reach here: " + type); }
            });
        } else if (l instanceof SequenceLayout) {
            sb.append("MemoryLayout.ofSequence(");
            if (((SequenceLayout) l).elementCount().isPresent()) {
                sb.append(((SequenceLayout) l).elementCount().getAsLong() + ", ");
            }
            addLayout(((SequenceLayout) l).elementLayout());
            sb.append(")");
        } else if (l instanceof GroupLayout) {
            SystemABI.Type type = l.abiType().orElse(null);
            if (type == SystemABI.Type.COMPLEX_LONG_DOUBLE) {
                if (!ABI.equals(SystemABI.ABI_SYSV)) {
                    throw new RuntimeException("complex long double is supported only for SysV ABI");
                } else {
                    sb.append("C_COMPLEX_LONGDOUBLE");
                }
            } else {
                if (((GroupLayout) l).isStruct()) {
                    sb.append("MemoryLayout.ofStruct(\n");
                } else {
                    sb.append("MemoryLayout.ofUnion(\n");
                }
                incrAlign();
                String delim = "";
                for (MemoryLayout e : ((GroupLayout) l).memberLayouts()) {
                    sb.append(delim);
                    indent();
                    addLayout(e);
                    delim = ",\n";
                }
                sb.append("\n");
                decrAlign();
                indent();
                sb.append(")");
            }
        } else {
            //padding
            sb.append("MemoryLayout.ofPaddingBits(" + l.bitSize() + ")");
        }
        if (l.name().isPresent()) {
            sb.append(".withName(\"" +  l.name().get() + "\")");
        }
    }

    protected void addVarHandle(String name, Class<?> type, Declaration parent, int dimensions) {
        String ty = type.getName();
        indent();
        sb.append(PUB_MODS + "VarHandle " + getVarHandleName(name, parent) + " = \n");
        incrAlign();
        indent();
        sb.append(getLayoutName(parent == null ? name : parent.name()));
        sb.append(".varHandle(" + ty + ".class");
        if (parent != null) {
            sb.append(", PathElement.groupElement(\"" + name + "\")");
        }
        for (int i = 0; i < dimensions; i++) {
            sb.append(", PathElement.sequenceElement()");
        }
        sb.append(")");
        sb.append(";\n");
        decrAlign();
    }

    private String getMethodHandleName(String name) {
        return "mh_" + name;
    }

    protected void addMethodHandle(Declaration.Function funcTree, MethodType mtype, FunctionDescriptor desc) {
        String mhVar = getMethodHandleName(funcTree.name());
        indent();
        sb.append("public static MethodHandle " + mhVar + ";\n");
        indent();
        sb.append(PUB_MODS + "MethodHandle get" + mhVar + "() {\n");
        incrAlign();
        indent();
        sb.append("if (" + mhVar + " == null) {\n");
        incrAlign();
        indent();
        sb.append(mhVar + " = RuntimeHelper.downcallHandle(\n");
        incrAlign();
        indent();
        sb.append("LIBRARIES, \"" + NamingUtils.getSymbolInLib(funcTree) + "\"");
        sb.append(",\n");
        indent();
        sb.append("\"" + mtype.toMethodDescriptorString() + "\",\n");
        indent();
        addFunction(desc);
        sb.append(", ");
        // isVariadic
        sb.append(funcTree.type().varargs());
        sb.append("\n");
        decrAlign();
        indent();
        sb.append(");\n");
        decrAlign();
        indent();
        sb.append("}\n");
        indent();
        sb.append("return " + mhVar + ";\n");
        sb.append("}\n");
        decrAlign();
    }

    protected void addAddressLookup(String name, String symbol) {
        sb.append("RuntimeHelper.lookupGlobalVariable(LIBRARIES, \"" + symbol + "\", "
                + getLayoutName(name) + ")");
    }

    private void addFunction(FunctionDescriptor f) {
        final boolean noArgs = f.argumentLayouts().isEmpty();
        if (f.returnLayout().isPresent()) {
            sb.append("FunctionDescriptor.of(");
            addLayout(f.returnLayout().get());
            if (!noArgs) {
                sb.append(",");
            }
        } else {
            sb.append("FunctionDescriptor.ofVoid(");
        }
        if (!noArgs) {
            sb.append("\n");
            incrAlign();
            String delim = "";
            for (MemoryLayout e : f.argumentLayouts()) {
                sb.append(delim);
                indent();
                addLayout(e);
                delim = ",\n";
            }
            sb.append("\n");
            decrAlign();
            indent();
        }
        sb.append(")");
    }

    protected void addAddress(String name, String symbol) {
        indent();
        sb.append(PUB_MODS + "MemoryAddress " + name + "$ADDR" + " = ");
        addAddressLookup(name, symbol);
        sb.append(";\n");
    }

    protected void addConstant(String name, Class<?> type, Object value) {
        indent();
        if (type == MemoryAddress.class || type == MemorySegment.class) {
            //todo, skip for now (address constants and string constants)
        } else {
            sb.append(PUB_MODS + type.getName() + " " + name);
            sb.append(" = ");
            if (type == float.class) {
                sb.append(value);
                sb.append("f");
            } else if (type == long.class) {
                sb.append(value);
                sb.append("L");
            } else if (type == double.class) {
                Double v = (Double) value;
                if (Double.isFinite(v)) {
                    sb.append(value);
                    sb.append("d");
                } else {
                    sb.append("Double.valueOf(\"");
                    sb.append(v.toString());
                    sb.append("\")");
                }
            } else {
                sb.append("(" + type.getName() + ")");
                sb.append(value + "L");
            }
            sb.append(";\n");
        }
    }

    static int funcIntfCounter = 0;

    protected void addUpcallFactory(FunctionDescriptor desc) {
        String fnName = "FI" + funcIntfCounter++;
        indent();
        sb.append(PRI_MODS + "FunctionDescriptor " + fnName + "$DESC = ");
        addFunction(desc);
        sb.append(";\n");
        indent();
        sb.append(PUB_MODS + "MemoryAddress " + fnName + "$make(MethodHandle handle) {\n");
        incrAlign();
        indent();
        sb.append("return RuntimeHelper.upcallStub(handle, " + fnName + "$DESC);\n");
        decrAlign();
        indent();
        sb.append("}\n");
    }

    protected void addStaticFunctionWrapper(Declaration.Function f, MethodType mtype) {
        indent();
        sb.append(PUB_MODS + mtype.returnType().getName() + " " + f.name() + "(");
        String delim = "";
        List<String> pNames = new ArrayList<>();
        for (int i = 0 ; i < f.parameters().size() ; i++) {
            String pName = f.parameters().get(i).name();
            if (pName.isEmpty()) {
                pName = "x" + i;
            } else {
                pName = NamingUtils.toSafeName(pName);
            }
            pNames.add(pName);
            sb.append(delim + mtype.parameterType(i).getName() + " " + pName);
            delim = ", ";
        }
        if (f.type().varargs()) {
            String lastArg = "x" + f.parameters().size();
            sb.append(", Object... " + lastArg);
            pNames.add(lastArg);
        }
        sb.append(") {\n");
        incrAlign();
        indent();
        sb.append("try {\n");
        incrAlign();
        indent();
        if (!mtype.returnType().equals(void.class)) {
            sb.append("return (" + mtype.returnType().getName() + ")");
        }
        sb.append("get" + getMethodHandleName(f.name()) + "().invokeExact(" + String.join(", ", pNames) + ");\n");
        decrAlign();
        indent();
        sb.append("} catch (Throwable ex) {\n");
        incrAlign();
        indent();
        sb.append("throw new AssertionError(ex);\n");
        decrAlign();
        indent();
        sb.append("}\n");
        decrAlign();
        indent();
        sb.append("}\n");
    }

    void addDescriptor(String name, FunctionDescriptor desc) {
        incrAlign();
        indent();
        sb.append(PRI_MODS + "FunctionDescriptor " + name + "$DESC = ");
        addFunction(desc);
        sb.append(";\n");
        decrAlign();
        indent();
    }

    void addFunctionalInterface(String name, MethodType mtype) {
        indent();
        sb.append("public interface " + name + " {\n");
        incrAlign();
        indent();
        sb.append(mtype.returnType().getName() + " apply(");
        String delim = "";
        for (int i = 0 ; i < mtype.parameterCount() ; i++) {
            sb.append(delim + mtype.parameterType(i).getName() + " x" + i);
            delim = ", ";
        }
        sb.append(");\n");
        decrAlign();
        indent();
        sb.append("}\n");
    }

    private String getVarHandleName(String name, Declaration parent) {
        return "vh_" + ((parent == null) ? name  : (parent.name() + "$" + name));
    }

    protected void addFunctionalFactory(String name, MethodType mtype) {
        indent();
        sb.append(PUB_MODS + "MemoryAddress " + name + "$make(" + name + " fi) {\n");
        incrAlign();
        indent();
        sb.append("return RuntimeHelper.upcallStub(" + name + ".class, fi, " + name + "$DESC, " +
                "\"" + mtype.toMethodDescriptorString() + "\");\n");
        decrAlign();
        indent();
        sb.append("}\n");
    }

    void addVHGetter(String name, Class<?> type, Declaration parent, int dimensions) {
        indent();
        String vhName = getVarHandleName(name, parent);
        String vhParam = parent != null ? "ptr()" : (name + "$ADDR");
        String vhGetStmt = vhName + ".get(" + vhParam ;
        for (int i = 0; i < dimensions; i++) {
            vhGetStmt += ", idx" + i;
        }
        vhGetStmt += ")";
        String typeName = type.getName();
        if (typeName.contains("MemoryAddress")) {
            typeName = "MemoryAddress";
        }
        vhGetStmt = "(" + typeName +") " + vhGetStmt;
        sb.append(parent == null ? PUB_MODS : PUB_CLS_MODS);
        sb.append(typeName + " " + name + "$get(");
        for (int i = 0; i < dimensions; i++) {
            if (i > 0) {
                sb.append(", ");
            }
            sb.append("long idx" + i);
        }
        sb.append(") {\n");
        incrAlign();
        indent();
        sb.append("return " + vhGetStmt + ";\n");
        decrAlign();
        indent();
        sb.append("}\n");
    }

    void addVHSetter(String name, Class<?> type, Declaration parent, int dimensions) {
        indent();
        String vhName = getVarHandleName(name, parent);
        String typeName = type.getName();
        String vhParam = parent != null ? "ptr()" : (name + "$ADDR");
        for (int i = 0; i < dimensions; i++) {
            vhParam += ", idx" + i;
        }
        if (typeName.contains("MemoryAddress")) {
            typeName = "MemoryAddress";
        }
        vhParam += ", x";
        sb.append(parent == null ? PUB_MODS : PUB_CLS_MODS);
        sb.append("void " + name + "$set(");
        for (int i = 0; i < dimensions; i++) {
            sb.append("long idx" + i +", ");
        }
        sb.append(typeName + " x) {\n");
        incrAlign();
        indent();
        sb.append(vhName + ".set(" + vhParam + ");\n");
        decrAlign();
        indent();
        sb.append("}\n");
    }

    void addCarrierGetter(String name, String typeName, Declaration parent, int dimensions) {
        indent();
        sb.append(parent == null ? PUB_MODS : PUB_CLS_MODS);
        sb.append(typeName + " " + name + "$get() {\n");
        incrAlign();
        indent();
        String addr = parent == null ? name + "$ADDR" :
                "getFieldAddr(\"" + StringUtils.quote(name) + "\")";
        sb.append("return " + typeName + ".at(" + addr + ");\n");
        decrAlign();
        indent();
        sb.append("}\n");
    }

    void addCarrierSetter(String name, String typeName, Declaration parent, int dimensions) {
        indent();
        sb.append(parent == null ? PUB_MODS : PUB_CLS_MODS);
        sb.append("void " + name + "$set(");
        sb.append(typeName + " x) {\n");
        incrAlign();
        indent();
        String addr = parent != null ?
                "ptr()" : name + "$ADDR";
        sb.append("MemoryAddress.copy(x.ptr(), ");
        sb.append(addr + ", x.getLayout().byteSize());\n");
        decrAlign();
        indent();
        sb.append("}\n");
    }

    void addAddress(String name, Declaration parent) {
        indent();
        sb.append(PUB_CLS_MODS + "MemoryAddress " + name + "$ptr() {\n");
        incrAlign();
        indent();
        sb.append("return getFieldAddr(\"" + StringUtils.quote(name) + "\");\n");
        decrAlign();
        indent();
        sb.append("}\n");
    }

    protected String build() {
        String res = sb.toString();
        this.sb = null;
        return res.toString();
    }

    protected void indent() {
        for (int i = 0; i < align; i++) {
            sb.append("    ");
        }
    }

    protected void incrAlign() {
        align++;
    }

    protected void decrAlign() {
        align--;
    }

    public void addLineBreak() {
        sb.append("\n");
    }

    public void addLineBreaks(int lines) {
        while (lines > 0) {
            sb.append("\n");
            lines--;
        }
    }
}
